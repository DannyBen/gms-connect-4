<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
    Connect 4 Game Engine in GameMaker: Studio
    
    Zack Banack
        http://zackbanack.com/
        @zackbanack
    
    November 17, 2017
        v1.0
    
    Associated Tutorial/Walkthrough
        http://zackbanack.com/blog/connect4
        
    End User License Agreement (EULA)
        http://zackbanack.com/EULA
        
    Notes
        - This asset was created for GameMaker: Studio, so non-documented adjustments may be required to get it working with GameMaker: Studio 2.
        - Because this is a free asset, support will be limited.
*/

// define the board
rows = 7;                                           // horizontal slots
cols = 6;                                           // vertical slots
grid = ds_grid_create(rows, cols);                  // create grid
empty = 2;                                          // player 0 = 0, player 1 = 1, empty = 2
ds_grid_set_region(grid, 0, 0,
    rows - 1, cols - 1, empty);                     // make the grid empty
board_x = 64;                                       // x-coordinate in room to draw board (grid)
board_y = 0;                                        // y-coordinate in room to draw board (grid)
slot_size = 128;                                    // size of each node in the grid
slot_radius = 48;                                   // radius of the circle, either a chip or empty
board_width = rows * slot_size;                     // total width of board (px)
board_height = cols * slot_size;                    // total height of board (px)

// this is Connect *4*, so we need four same-colored chips in a row to win
needed = 4;

// define colors
background_color[0] = c_black;
slot_color[0]   = make_colour_rgb(241, 196, 15);    // empty
slot_color[1]   = make_colour_rgb(231, 76, 60);     // player 0
slot_color[2]   = make_colour_rgb(18, 151, 224);    // player 1
container_color = make_colour_rgb(41, 197, 255);    // color of board
line_color      = make_colour_rgb(28, 42, 57);      // color of winning line

highlight_color = c_white;                          // color of highlighted column
highlight_alpha = 0.25;                             // transparency of highlight

// define player names and who goes first
player_name[0] = "Yellow";
player_name[1] = "Red";
turn = 0;

// win/lose conditions
game_over = false;  // game has ended
nobody_wins = false; // game ends in a draw

// winning sequence start and end x and y grid position to draw line
line_start_x    = -1;
line_start_y    = -1;
line_end_x      = -1;
line_end_y      = -1;
line_thickness  = 8;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var offset, occupied_tops;
offset = (slot_size * 0.5);     // center the circle
occupied_tops = 0;              // how many columns are open; used to determine a full board

// draw the board container
draw_set_color(container_color);
draw_rectangle(board_x, board_y, board_x + board_width, board_y + board_height, false);

// game rendering and logic
for (var i = 0; i &lt; rows; i++) { // cycle through rows
    var _x, _y; // temp positioning vars
    _x = board_x + (i * slot_size); // x-coordinate for slot
    
    // if the top space in each column is not free, increase the counter
    if (ds_grid_get(grid, i, 0) != empty) {
        occupied_tops++;
    }
    
    for (var j = 0; j &lt; cols; j++) { // cycle through columns
        _y = board_y + (j * slot_size); // y-coordinate for slot

        // set slot color based on grid node value (0, 1, or 2) and draw the circle
        draw_set_color(slot_color[ds_grid_get(grid, i, j)]);
        draw_circle(_x + offset, _y + offset, slot_radius, false);
    }

    // check if the cursor is in the column
    if (point_in_rectangle(mouse_x, mouse_y, _x, board_y, _x + slot_size - 1, board_y + board_height)) {
    
        // condition to place a chip
        if (ds_grid_get(grid, i, 0) == empty &amp;&amp; !game_over) {
        
            // draw the highlight
            draw_set_color(highlight_color);
            draw_set_alpha(highlight_alpha);
            draw_rectangle(_x, board_y, _x + slot_size, board_y + board_height, false);
            draw_set_alpha(1);
            
            // draw a chip ready to be dropped; indicates player's turn
            draw_set_color(slot_color[turn]);
            draw_circle(_x + offset, board_y, slot_radius, false);

            // player places a chip by pressing the left mouse button
            if (mouse_check_button_pressed(mb_left)) {
                // iterate through column from the bottom until we find an empty space
                var pos_y = cols;

                do {
                    pos_y--;
                }
                until(ds_grid_get(grid, i, pos_y) == empty);

                // update the empty position to the player number (0 or 1)
                ds_grid_set(grid, i, pos_y, turn);

                // check if the move resulted in a win
                var check = check_win(turn);

                // either end the game in success or change players
                if (check) {
                    game_over = true;
                } else {
                    turn = !turn;
                }
            }
        }
    }
    
    // if no columns are open, the entire board is full - end the game and nobody wins
    if (occupied_tops == rows &amp;&amp; !game_over) {
        game_over = true;
        nobody_wins = true;
    }
}

// only execute the following code when the game ends
if (game_over) {

    // drawing winning line
    draw_set_color(line_color);
    draw_line_width(board_x + offset + (line_start_x * slot_size), board_y + offset + (line_start_y * slot_size),
        board_x + offset + (line_end_x * slot_size), board_y + offset + (line_end_y * slot_size), line_thickness);
    
    // prepare the text drawing
    draw_set_font(fnt32);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_color(c_white);
    
    // a string to show which player won
    var winner = "Player " + string(player_name[turn]) + " wins!";
    
    // change the string in the event neither player won
    if (nobody_wins) {
        winner = "Draw!";
    }
    
    // draw the text
    draw_text(room_width * 0.5, room_height * 0.5, string(winner) + "#Press space to play again.");

    // restart the game when the player presses space
    if (keyboard_check_pressed(vk_space)) {
        room_restart();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
